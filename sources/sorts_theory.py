# coding: utf-8

"""
__Оценка сложности алгоритмов, время сортировок и
основная теорема о рекуррентных соотношениях__

Материалы: лекция 13.01, 20.01.

Лектор: Объедков Сергей Александрович<br>
Семинарист: Макаров Илья Андреевич<br>
Конспектировал Гончаров Владимир

"""

#d

"""
## Оценка сложности алгоритмов

Для оценки времени и памяти, которая уходит на выполнение алгоритма на
входных данных размера \\(n \\) нам нужно знать, сколько операций
совершит алгоритм и сколько памяти он потребляет.
Однако часто это сделать сложно, особенно если мы ничего не знаем
о природе данных (как долго происходит сложение, к примеру?) и архитектуре.

Но часто это и не требуется: мы лишь хотим оценить, как растет время
(или память) с ростом входных данных. Для этого можно математическими
методами оценить количество требуемых ресурсов и записать ответ в виде
эквивалентных функций.

Применяются следующие обозначения:

\\(f = \bar{\bar{o}}(g) \Rightarrow \forall ~ c > 0 ~ \exists ~ n_0 > 0 :
    \forall ~ n > n_0 \Rightarrow (0 \le f < cg)(n) \\)

\\(f = \omega(g) \Rightarrow \forall ~ c > 0 ~ \exists ~ n_0 > 0 :
    \forall ~ n > n_0 \Rightarrow (0 \le cf < g)(n) \\)

\\(f = O(g) \Rightarrow \exists ~ c, n_0 > 0 :
    \forall ~ n > n_0 \Rightarrow (0 \le f \le cg)(n) \\)

\\(f = \Omega(g) \Rightarrow \exists ~ c, n_0 > 0 :
    \forall ~ n > n_0 \Rightarrow (0 \le cf \le g)(n) \\)

\\(f = \Theta(g) \Rightarrow \exists ~ c_1, c_2, n_0 > 0 :
    \forall ~ n > n_0 \Rightarrow (0 \le c_1g \le f \le c_2g)(n)\\)

Более подробное описание терминов [на википедии][1].

Стоит заметить, что «О» задают класс функций.

[1]:https://ru.wikipedia.org/wiki/«O»_большое_и_«o»_малое#.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D0.BE.D0.B4.D0.BE.D0.B1.D0.BD.D1.8B.D0.B5_.D0.BE.D0.B1.D0.BE.D0.B7.D0.BD.D0.B0.D1.87.D0.B5.D0.BD.D0.B8.D1.8F

"""

#d

"""
## Время сортировок

Рассматривается минимальная оценка времени сортировок
при том, что известна только длинна массива. Считаем, что
сравнение элементов требует \\(O(1) \\) времени, остальные операции
мы не учитываем (оценка-то нижняя).

Можно построить дерево сравнений. В вершине такого дерева
будет стоять операция сравнения двух элементов, от каждой вершины
идут вних две ветви — верно сравнение, или нет.

Пример для массива \\(n=3\\):

            1>2
           /   \
        2>3     2>3
        / \     / \
      3>1 3>1 3>1 3>1
      / \ / \ / \ / \
    [конечные состояния]

Всего конечных состояний (ответов) не менее \\(n! \\), по количеству возможных
перестановок в массиве. Тогда глубина дерева — не менее
\\(\log n! \ge
    \log \left( \left(\frac{n}{2} \right)^{\frac{n}{2}} \right) \ge
    \frac{n}{2} \log  \left(\frac{n}{2} \right) \ge
    O \left(n\log n \right) \\)

"""

#d

"""
## Разделяй и властвуй

Техника рекурсивного решения задач, применяемая, в частности,
во многих сортировках (см. [[sorts.py#section-6]] —
сортировка слиянием и qsort).

Общий смысл таков: на каждом шаге мы разделяем входные даные
на несколько частей (чаще всего равных), после чего
рекурсивно запускаем тот же алгоритм на этих частях.
После этого мы как-то анализируем полученные данные.

При таком подходе в зависимости от того, на каое количество частей
мы разделили массив и от того, сколько выполняется обработка результатов,
мы будем получать оценки времени от \\(O(n) \\). Точные соотношения
описываются основной теоремой о рекуррентных соотношениях.

"""

#d

"""
## Основная теорема о рекуррентных соотношениях (master theorem)

Основная теорема о рекуррентных соотношениях обобщает результаты
времени, получающиеся при применении техники «разделяй и властвуй».

Пусть на каждом участке мы делим исходную задачу
на \\(a \\) подзадач, размер каждой — \\(n/b \\),
и на анализ уходит полиноминальное время \\(O(n^d) \\).

Если время работы алгоритма на массиве длинны \\(n \\)&nbsp;— \\(T[n] \\),
справедливо соотношение \\(T[n] = a T[n/b] + f(n) \\).

Теорема утверждает, что

\\(T[n] =
\begin{cases}
    \Theta(f(n)),               &
        \mbox{если } f(n) = \Omega(n^c), c > log_b a \\\\
    \Theta(n^c\log^{k+1} n),    &
        \mbox{если } \exists ~ k \ge 0 :
        f(n) = \Theta(n^c\log^kn), c = log_b a \\\\
    \Theta(n^{\log_b a}),       &
        \mbox{если } f(n) = O(n^c), c < \log_b a
\end{cases}\\)

"""
