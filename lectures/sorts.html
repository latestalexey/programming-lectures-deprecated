<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>sorts.py</title>
  <link rel="stylesheet" href="pycco.css">
  
  <!--MathJax for LaTeX formulas-->
  <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

</head>
<body>
<div id='container'>
  <div id="background"></div>
  <div class='section'>
    <div class='docs'><h1>sorts.py</h1></div>
  </div>
  <div class='clearall'>
  <div class='section' id='section-0'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-0'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-1'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-1'>#</a>
      </div>
      <p><strong>Оценка сложности алгоритмов, сортировки</strong></p>
<p>Материалы: лекция 1 (13.01), 2 (16.05), семинар 2 (15.01).</p>
<p>Лектор: Объедков Сергей Александрович<br>
Семинарист: Макаров Илья Андреевич<br>
Конспектировал Гончаров Владимир</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">speedtest</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-2'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-2'>#</a>
      </div>
      <h2>Оценка сложности алгоритмов</h2>
<p>Для оценки времени и памяти, которая уходит на выполнение алгоритма на
входных данных размера <em>n</em> нам нужно знать, сколько операций совершит алгоритм
и сколько памяти он потребляет. Однако часто это сделать сложно,
особенно если мы ничего не знаем о природе данных (как долго происходит
сложение, к примеру?) и архитектуре.</p>
<p>Но часто это и не требуется: мы лишь хотим оценить, как растет время
(или память) с ростом входных данных. Для этого можно математическими
методами оценить количество требуемых ресурсов и записать ответ в виде
эквивалентных функций.</p>
<p>Применяются следующие обозначения:</p>
<p>\(f = \bar{\bar{o}}(g) \Rightarrow \forall ~ c &gt; 0 ~ \exists ~ n_0 &gt; 0 :
    \forall ~ n &gt; n_0 \Rightarrow (0 \le f &lt; cg)(n) \)</p>
<p>\(f = \omega(g) \Rightarrow \forall ~ c &gt; 0 ~ \exists ~ n_0 &gt; 0 :
    \forall ~ n &gt; n_0 \Rightarrow (0 \le cf &lt; g)(n) \)</p>
<p>\(f = O(g) \Rightarrow \exists ~ c, n_0 &gt; 0 :
    \forall ~ n &gt; n_0 \Rightarrow (0 \le f \le cg)(n) \)</p>
<p>\(f = \Omega(g) \Rightarrow \exists ~ c, n_0 &gt; 0 :
    \forall ~ n &gt; n_0 \Rightarrow (0 \le cf \le g)(n) \)</p>
<p>\(f = \Theta(g) \Rightarrow \exists ~ c_1, c_2, n_0 &gt; 0 :
    \forall ~ n &gt; n_0 \Rightarrow (0 \le c_1g \le f \le c_2g)(n)\)</p>
<p>Более подробное описание терминов <a href="https://ru.wikipedia.org/wiki/«O»_большое_и_«o»_малое#.D0.94.D1.80.D1.83.D0.B3.D0.B8.D0.B5_.D0.BF.D0.BE.D0.B4.D0.BE.D0.B1.D0.BD.D1.8B.D0.B5_.D0.BE.D0.B1.D0.BE.D0.B7.D0.BD.D0.B0.D1.87.D0.B5.D0.BD.D0.B8.D1.8F">на википедии</a>.</p>
<p>Стоит заметить, что <em>«О»</em> задают класс функций.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-3'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-3'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-4'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-4'>#</a>
      </div>
      <h2>Сортировка выбором (selection sort)</h2>
<p>В представлении не нуждается, работает за \(O(n^2) \), есть стабильный вариант.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">selection_sort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="c"># Нестабильный вариант</span>
    <span class="c"># Обратите внимание, что эта функция является</span>
    <span class="c"># модификативной (in place) и использует O(1) дополнительной памяти.</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="nb">max</span><span class="p">]:</span>
                <span class="nb">max</span> <span class="o">=</span> <span class="n">j</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="nb">max</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="nb">max</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">a</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-5'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-5'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-6'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-6'>#</a>
      </div>
      <h2>Сортировка вставками (insertion sort)</h2>
<p>Устойчивая сортировка, эффективная на небольших объемах данных.</p>
<p>На каждом шаге элемент перемещается назад по массиву до тех пор, пока
перед ним находится больший элемент. Таким образом у нас есть
начало массива, отсортированное на предыдущих шагах и элемент
на <em>i</em>-м месте, который нужно поместить в отсортированную часть так,
чтобы она осталась отсортированной.</p>
<p>«Данный алгоритм можно ускорить при помощи использования
бинарного поиска для нахождения места текущему элементу в
отсортированной части. Проблема с долгим сдвигом массива вправо
решается при помощи смены указателей»&nbsp;— Википедия</p>
<p><strong>Время работы:</strong></p>
<p>\(O(n^2) \) в худшем случае: входной массив отсортирован в порядке,
обратном нужному, на каждом участке цикла по <em>i</em> происходит
<em>i</em> операций в цикле по <em>k</em>.</p>
<p>\(O(n) \) в лучшем: массив уже отсортирован,
на каждом участке цикла по <em>i</em> происходит \( O(1)\) операций.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="c"># Как и `selection_sort`, in place функция</span>
    <span class="c"># использует O(1) дополнительной памяти.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="n">a</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-7'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-7'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-8'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-8'>#</a>
      </div>
      <h2>Сортировка слиянием (merge sort)</h2>
<p>Алгоритм рекурсивный: на каждом шаге мы разделяем массив
на две части и сортируем каждую отдельно (тем же самым алгоритмом),
после чего сливаем две части вместе.</p>
<p><strong>Время работы</strong> \(O(n \log n) \).</p>
<p>Если время работы алгоритма на массиве длинны \(n \)&nbsp;— \(T[n] \),
то по определению справедливо рекуррентное соотношение
\(T[n] = 2T[n/2] + O(n) \): две сортировки массивов размера
\(n/2 \) и еще n операций на слияние.</p>
<p>Можно убедиться, что \(T[n] = O(n \log n) \), используя
<a href="https://ru.wikipedia.org/wiki/Основная_теорема_о_рекуррентных_соотношениях">основную теорему о рекуррентных соотношениях</a>.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">:</span>
        <span class="c"># Часто insertion_sort показывает лучшие результаты</span>
        <span class="c"># на небольших массивах.</span>
        <span class="k">return</span> <span class="n">insertion_sort</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:])</span>

        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">result</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-9'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-9'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-10'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-10'>#</a>
      </div>
      <h2>Быстрая сортировка (qsort)</h2>
<p>Алгоритм быстрой сортировки&nbsp;— объединение идеи пузырьковой сортировки
и сортировки слиянием.</p>
<p>На каждом шаге мы выбираем «опорный элемент» («pivot element»),
после чего переносим все элементы, меньшие опорного,&nbsp;— налево,
большие&nbsp;— направо. После этого мы запускаем сортировку на левой
и правой части массива (центральную не трогаем). Заметим, что после
этой операции не нужно проводить слияние.</p>
<p><strong>Опорный элемент:</strong></p>
<p>Выбор опорного элемента напрямую влияет на скорость алгоритма:
самым оптимальным выбором будет медиана, самым худшим&nbsp;—
выбор наименьшего или наибольшего элемента. Так как искать медиану
без дополнительных элементов сложно, используют разные ухищрения:
средний из максимального и минимального элемента, случайный элемент,
медиана из первого, среднего и последнего элемента и т. д.</p>
<p><strong>Время работы:</strong></p>
<p>В in place реализации выполняется в среднем за \(O(n \log n) \).</p>
<p>При этом в худшем случае, когда в качестве опорного элемента
выбирается минимальный или максимальный элемент,
на каждом шаге мы имеем деление массива
на отрезки [0] и [1, n) за \(n - 1 \) операцию обмена,
что ухудшает время до \(O(n^2) \).</p>
<p>Средний случай подробнее:</p>
<p>Средний, то есть «удачный» случай разделения — случай, когда
опорный элемент близок к медиане. Если предположить, что он
попадает в центральную чать массива (т. е. отстоит от медианы не более,
чем на <em>0,25n</em>, вероятность чего составит 50% при случайном выборе элемента),
глубина рекурсии составит не более, чем \(\log_{4/3} n\), и поскольку
на каждом уровне рекурсии выполняется <em>n</em> операций, мы получаем оценку в
\(O(n \log n) \).</p>
<p><strong>Глубина рекурсии:</strong></p>
<p>В худшем случае глубина рекурсии составляет \(O(n) \).
Существует несколько выходов из ситуации. В их числе:</p>
<ul>
<li>Переход на другой вид сортировки при привышении лимита глубины
    (см. <a href="https://ru.wikipedia.org/wiki/Introsort">introsort</a>)</li>
<li>Перестройка алгоритма с использованием хвостовой рекурсии:
    сортировать две полученные части массива в рамках одного вызова.
    К примеру, вместо <code>left</code> и <code>right</code> передавать список вида
    <code>[[left, middle], [middle, right]]</code> и сортировать отрезки в одном цикле.</li>
</ul>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">quick_sort_inplace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c"># В качестве опорного элемента выбирается случайный.</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">])</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">quick_sort_inplace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">quick_sort_inplace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="c"># Пример реализации с использованием списковых сборок.</span>
    <span class="c"># Красиво, компактно, но памяти используется больше.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">quick_sort</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">])</span> <span class="o">+</span>
                <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">pivot</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">quick_sort</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">]))</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-11'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-11'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-12'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-12'>#</a>
      </div>
      <h2>Сортировка кучей (heap sort, пирамидальная сортировка)</h2>
<p>Описание скоро будет...</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="c"># FIXME</span>
    <span class="c"># Тесты показывают, что этот алгоритм ужасен.</span>
    <span class="c"># Возможно, у кого-то есть более быстрая реализация — пришлите, пожалуйста</span>

    <span class="k">def</span> <span class="nf">l_ch</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="c"># Left child</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">r_ch</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="c"># Right child</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">push_down</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">):</span>
        <span class="c"># `max_depth` нужна, чтобы не трогать отсортированную часть кучи</span>

        <span class="n">get_gt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">else</span> <span class="n">j</span>

        <span class="k">while</span> <span class="n">l_ch</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_depth</span><span class="p">:</span>
            <span class="c"># Выбираем элемент, на место которого нужно протолкнуть корень</span>
            <span class="n">gt_ch</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_gt</span><span class="p">(</span><span class="n">l_ch</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">r_ch</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                     <span class="k">if</span> <span class="n">r_ch</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_depth</span> <span class="k">else</span>
                     <span class="n">l_ch</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">gt_ch</span><span class="p">]:</span>
                <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">gt_ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">gt_ch</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">i</span> <span class="o">=</span> <span class="n">gt_ch</span>

    <span class="c"># Строим кучу</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">push_down</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

    <span class="c"># Сортируем кучу</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">push_down</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">a</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
</div>
</body>
