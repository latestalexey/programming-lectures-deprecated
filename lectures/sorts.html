<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>sorts.py</title>
  <link rel="stylesheet" href="pycco.css">

  <!--MathJax for LaTeX formulas-->
  <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

</head>
<body>
<div id='container'>
  <div id="background"></div>
  <div class='section'>
    <div class='docs'>
        <h1>sorts.py</h1>
$$
\newcommand{\FFT}{\mathop{\text{FFT}}}
\renewcommand{\le}{\leqslant}
\renewcommand{\ge}{\geqslant}
\renewcommand{\O}{\varnothing}
\renewcommand{\Im}{\mathop{\text{Im}}}
\renewcommand{\Re}{\mathop{\text{Re}}}
\newcommand{\sgn}{\mathop{\text{sgn}}}
\newcommand{\degree}{\llap{~}^{\circ}}
\renewcommand{\kappa}{\varkappa}
\renewcommand{\epsilon}{\varepsilon}
\renewcommand{\phi}{\varphi}
\newcommand{\E}{\mathsf{E}}
\newcommand{\pdef}{\mathrel{\stackrel{\rm def}{=}}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\No}{\mathbb{N}^{\, \cup 0}}
\newcommand{\Ni}{\mathbb{N}^{\setminus \! 0}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\QP}{\mathbb{Q}^{+}}
\newcommand{\RP}{\mathbb{R}^{+}}
\newcommand{\so}{\Rightarrow}
\renewcommand{\:}{\colon}
\newcommand{\intl}{\int\limits}
\newcommand{\iintl}{\iint\limits}
\newcommand{\iiintl}{\iiint\limits}
\newcommand{\iiiintl}{\iiiint\limits}
\newcommand{\idotsintl}{\idotsint\limits}
$$
    </div>
  </div>
  <div class='clearall'>
  <div class='section' id='section-0'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-0'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-1'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-1'>#</a>
      </div>
      <p><strong>Cортировки</strong></p>
<p>Материалы: лекция 13.01, 16.05, семинар 2 15.01.</p>
<p>Лектор: Объедков Сергей Александрович<br>
Семинарист: Макаров Илья Андреевич<br>
Конспектировал Гончаров Владимир</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">tests</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-2'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-2'>#</a>
      </div>
      <h2>Сортировка выбором (selection sort)</h2>
<p>В представлении не нуждается, работает за \(O(n^2) \),
есть стабильный вариант.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">selection_sort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="c"># Нестабильный вариант</span>
    <span class="c"># Обратите внимание, что эта функция является</span>
    <span class="c"># модификативной (in place) и использует O(1) дополнительной памяти.</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">maximum</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">maximum</span><span class="p">]:</span>
                <span class="n">maximum</span> <span class="o">=</span> <span class="n">j</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">maximum</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">maximum</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">a</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-3'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-3'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-4'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-4'>#</a>
      </div>
      <h2>Сортировка вставками (insertion sort)</h2>
<p>Устойчивая сортировка, эффективная на небольших объемах данных.</p>
<p>На каждом шаге элемент перемещается назад по массиву до тех пор, пока
перед ним находится больший элемент. Таким образом у нас есть
начало массива, отсортированное на предыдущих шагах и элемент
на \(i \)-м месте, который нужно поместить в отсортированную часть так,
чтобы она осталась отсортированной.</p>
<p>«Данный алгоритм можно ускорить при помощи использования
бинарного поиска для нахождения места текущему элементу в
отсортированной части. Проблема с долгим сдвигом массива вправо
решается при помощи смены указателей»&nbsp;— Википедия</p>
<p><strong>Время работы:</strong></p>
<p>\(O(n^2) \) в худшем случае: входной массив отсортирован в порядке,
обратном нужному, на каждом участке цикла по \(i \) происходит
\(i \) операций в цикле по \(k \).</p>
<p>\(O(n) \) в лучшем: массив уже отсортирован,
на каждом участке цикла по \(i \) происходит \( O(1)\) операций.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="c"># Как и `selection_sort`, in place функция</span>
    <span class="c"># использует O(1) дополнительной памяти.</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="n">a</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-5'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-5'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-6'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-6'>#</a>
      </div>
      <h2>Сортировка слиянием (merge sort)</h2>
<p>Алгоритм рекурсивный: на каждом шаге мы разделяем массив
на две части и сортируем каждую отдельно (тем же самым алгоритмом),
после чего сливаем две части вместе.</p>
<p><strong>Время работы</strong> \(O(n \log n) \).</p>
<p>По определению справедливо рекуррентное соотношение
\(T[n] = 2T[n/2] + O(n) \): две сортировки массивов размера
\(n/2 \) и еще n операций на слияние.</p>
<p>Можно убедиться, что \(T[n] = O(n \log n) \), используя
<a href="https://ru.wikipedia.org/wiki/Основная_теорема_о_рекуррентных_соотношениях">основную теорему о рекуррентных соотношениях</a>
(см. <a href="sorts_theory.html#section-5">sorts_theory.py</a>).</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">:</span>
        <span class="c"># Часто insertion_sort показывает лучшие результаты</span>
        <span class="c"># на небольших массивах.</span>
        <span class="k">return</span> <span class="n">insertion_sort</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">a</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">merge_sort</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:])</span>

        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">:]</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">result</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-7'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-7'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-8'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-8'>#</a>
      </div>
      <h2>Быстрая сортировка (qsort)</h2>
<p>Алгоритм быстрой сортировки&nbsp;— объединение идеи пузырьковой сортировки
и сортировки слиянием.</p>
<p>На каждом шаге мы выбираем «опорный элемент» («pivot element»),
после чего переносим все элементы, меньшие опорного,&nbsp;— налево,
большие&nbsp;— направо. После этого мы запускаем сортировку на левой
и правой части массива (центральную не трогаем). Заметим, что после
этой операции не нужно проводить слияние.</p>
<p><strong>Опорный элемент:</strong></p>
<p>Выбор опорного элемента напрямую влияет на скорость алгоритма:
самым оптимальным выбором будет медиана, самым худшим&nbsp;—
выбор наименьшего или наибольшего элемента. Так как искать медиану
без дополнительных элементов сложно, используют разные ухищрения:
средний из максимального и минимального элемента, случайный элемент,
медиана из первого, среднего и последнего элемента и т. д.</p>
<p><strong>Время работы:</strong></p>
<p>В in place реализации выполняется в среднем за \(O(n \log n) \).</p>
<p>При этом в худшем случае, когда в качестве опорного элемента
выбирается минимальный или максимальный элемент,
на каждом шаге мы имеем деление массива
на отрезки [0] и [1, n) за \(n - 1 \) операцию обмена,
что ухудшает время до \(O(n^2) \).</p>
<p><strong>Средний случай подробнее:</strong></p>
<p>Средний, то есть «удачный» случай разделения — случай, когда
опорный элемент близок к медиане. Если предположить, что он
попадает в центральную чать массива (т. е. отстоит от медианы не более,
чем на \(0{,}25n \), вероятность чего составит 50% при случайном выборе элемента),
глубина рекурсии составит не более, чем \(\log_{4/3} n\), и поскольку
на каждом уровне рекурсии выполняется \(n \) операций, мы получаем оценку в
\(O(n \log n) \).</p>
<p><strong>Глубина рекурсии:</strong></p>
<p>В худшем случае глубина рекурсии составляет \(O(n) \).
Существует несколько выходов из ситуации. В их числе:</p>
<ul>
<li>Переход на другой вид сортировки при привышении лимита глубины
    (см. <a href="https://ru.wikipedia.org/wiki/Introsort">introsort</a>)</li>
<li>Перестройка алгоритма с использованием хвостовой рекурсии:
    сортировать две полученные части массива в рамках одного вызова.
    К примеру, вместо <code>left</code> и <code>right</code> передавать список вида
    <code>[[left, middle], [middle, right]]</code> и сортировать отрезки в одном цикле.</li>
</ul>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">quick_sort_inplace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c"># В качестве опорного элемента выбирается случайный.</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">j</span><span class="p">])</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="n">quick_sort_inplace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">quick_sort_inplace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="c"># Пример реализации с использованием списковых сборок.</span>
    <span class="c"># Красиво, компактно, но памяти используется больше.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">quick_sort</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">])</span> <span class="o">+</span>
                <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">pivot</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">quick_sort</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">]))</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-9'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-9'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-10'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-10'>#</a>
      </div>
      <h2>Сортировка кучей (heap sort, пирамидальная сортировка)</h2>
<p>Как известно, идеально сбалансированное бинарное дерево
может быть записано в массив размера \(n \).
Heap sort использует бинарное сортирующее дерево, свойства которого
таковы: каждый родитель не меньше своего потомка.</p>
<p>Алгоритм сначала строит на базе массива сортирующее дерево,
а потом, собственно, сортирует.</p>
<p>Анимация всего процесса
<a href="http://www.youtube.com/watch?v=R6x7OuF_dYM#t=11">на youtube</a>
(качество плохое, но лучше я не нашел).</p>
<p>Часть 1: Построение кучи. Начиная с конца предпоследнего уровня
двигаемся к началу, на каждом шаге пытаясь «протолкнуть» элемент ниже:
если больший потомок меньше родителя, меняем их местами,
и так спускаемся в кучу до тех пор, пока не обнаружим, что оба
потомка больше родителя или что дальше двигаться нельзя (нижний уровень).
В результате этих операций наибольший элемент окажется наверху.</p>
<p>Часть 2: Меняем местами наибольший элемент с последним. Его больше трогать
не нужно, он на своем месте. Теперь наибольший стоит в конце,
а тот, что стоит в корне мы пропихиваем вниз,
в результате чего в корне оказывается второй по величине элемент.
Переставляем его в конец и повторяем операцию. Так потихоньку массив
отсортируется.</p>
<p>На каждом шаге мы \(n \) элементов проталкиваем на глубину не большую,
чем \(\log n \). Так мы получаем гарантированную оценку сложности
\(O(n\log n) \), однако проблема в том, что эта штука всегда работает
за \(O(n\log n) \), даже если ей дать уже отсортированный массив.
Из-за этого она проигрывает по скорости многим другим сортировкам.</p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">def</span> <span class="nf">heapify</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">):</span>
    <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="n">maximum</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">if</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">max_depth</span> <span class="ow">and</span> <span class="n">a</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="n">maximum</span> <span class="o">=</span> <span class="n">right</span>
    <span class="k">if</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">max_depth</span> <span class="ow">and</span> <span class="n">a</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">maximum</span><span class="p">]:</span>
        <span class="n">maximum</span> <span class="o">=</span> <span class="n">left</span>
    <span class="k">if</span> <span class="n">maximum</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">maximum</span><span class="p">]</span>
        <span class="n">a</span><span class="p">[</span><span class="n">maximum</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="n">heapify</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="c"># Новая реализация heapsort</span>
    <span class="c"># Алексей Башлыков</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">heapify</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

    <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">size</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">heapify</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">old_slow_heap_sort</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="c">#  Старая реализация — медленна и убога...</span>

    <span class="k">def</span> <span class="nf">l_ch</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="c"># Left child</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">r_ch</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="c"># Right child</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">push_down</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">):</span>
        <span class="c"># `max_depth` нужна, чтобы не трогать отсортированную часть кучи</span>

        <span class="n">get_gt</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span> <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">else</span> <span class="n">j</span>

        <span class="k">while</span> <span class="n">l_ch</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_depth</span><span class="p">:</span>
            <span class="c"># Выбираем элемент, на место которого нужно протолкнуть корень</span>
            <span class="n">gt_ch</span> <span class="o">=</span> <span class="p">(</span><span class="n">get_gt</span><span class="p">(</span><span class="n">l_ch</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">r_ch</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                     <span class="k">if</span> <span class="n">r_ch</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_depth</span> <span class="k">else</span>
                     <span class="n">l_ch</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">gt_ch</span><span class="p">]:</span>
                <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">gt_ch</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">gt_ch</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">i</span> <span class="o">=</span> <span class="n">gt_ch</span>

    <span class="c"># Строим кучу</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">push_down</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

    <span class="c"># Сортируем кучу</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">push_down</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">a</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-11'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-11'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-12'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-12'>#</a>
      </div>
      <h2>Тестирование сортировок</h2>
<p><a href="tests.html">tests.py</a></p>
<p><strong>Тест на случайно упорядоченных массивах (T[n]):</strong></p>
<p><img alt="Test 1" src="../images/sorts_t1.png" />
<img alt="Test 2" src="../images/sorts_t2.png" />
<img alt="Test 3" src="../images/sorts_t3.png" /></p>
    </div>
    <div class='code'>
      <div class="highlight"><pre><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">functions</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c"># Название, тестируемая ф-я, ограничитель</span>
        <span class="p">[</span><span class="s">&#39;Selection sort&#39;</span><span class="p">,</span> <span class="n">selection_sort</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">],</span>
        <span class="p">[</span><span class="s">&#39;Insertion sort&#39;</span><span class="p">,</span> <span class="n">insertion_sort</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">],</span>
        <span class="p">[</span><span class="s">&#39;Merge sort&#39;</span><span class="p">,</span> <span class="n">merge_sort</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
        <span class="p">[</span><span class="s">&#39;Qsort in place&#39;</span><span class="p">,</span> <span class="n">quick_sort_inplace</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
        <span class="p">[</span><span class="s">&#39;Quick sort&#39;</span><span class="p">,</span> <span class="n">quick_sort</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
        <span class="p">[</span><span class="s">&#39;Heap sort&#39;</span><span class="p">,</span> <span class="n">heap_sort</span><span class="p">,</span> <span class="bp">None</span><span class="p">],</span>
        <span class="p">[</span><span class="s">&#39;Old heap sort&#39;</span><span class="p">,</span> <span class="n">old_slow_heap_sort</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">],</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">50</span><span class="p">)))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="n">expected</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Output:&#39;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;Expected:&#39;</span><span class="p">,</span> <span class="n">expected</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s">&#39;ERROR! &#39;</span> <span class="o">+</span> <span class="n">n</span> <span class="o">+</span> <span class="s">&#39; is incorrect!&#39;</span><span class="p">)</span>

    <span class="c"># Тест на случайно упорядоченных массивах</span>
    <span class="k">def</span> <span class="nf">test_preparer</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">array</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">array</span><span class="p">]</span>

    <span class="n">tests</span><span class="o">.</span><span class="n">timetest</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span>
                   <span class="n">range_set</span><span class="o">=</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span> <span class="n">test_preparer</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">501</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
                              <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">test_preparer</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)],</span>
                              <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">test_preparer</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">105000</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)],</span>
                              <span class="p">),</span>
                   <span class="n">time_to_repeat</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                   <span class="n">output</span><span class="o">=</span><span class="s">&#39;csv&#39;</span><span class="p">)</span></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
  <div class='section' id='section-13'>
    <div class='docs'>
      <div class='octowrap'>
        <a class='octothorpe' href='#section-13'>#</a>
      </div>
      
    </div>
    <div class='code'>
      <div class="highlight"><pre></pre></div>
    </div>
  </div>
  <div class='clearall'></div>
</div>
</body>